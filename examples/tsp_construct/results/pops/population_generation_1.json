[
     {
          "algorithm": "\nPropose an algorithm that selects the next node based on a combination of the nearest unvisited node in terms of Euclidean distance and the node with the maximum number of connections to unvisited nodes, aiming to balance between short-term and long-term optimization; \n1. Calculate the Euclidean distance from the current node to each unvisited node.\n2. Determine the nearest unvisited node `nearest_node`.\n3. Calculate the total connections from each unvisited node to other unvisited nodes.\n4. Determine the unvisited node with the maximum connections, breaking ties by choosing the closest to the current node as the next node `next_node`.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances = np.sqrt(np.sum((distance_matrix[unvisited_nodes] - distance_matrix[current_node])**2, axis=1))\n    nearest_node = unvisited_nodes[np.argmin(distances)]\n    \n    connections = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes] > 0, axis=1)\n    max_connections_node = unvisited_nodes[np.argmax(connections)]\n    \n    if nearest_node == max_connections_node:\n        next_node = nearest_node\n    else:\n        next_node = min(nearest_node, max_connections_node)\n    \n    return next_node",
          "objective": 6.59703,
          "other_inf": null
     },
     {
          "algorithm": "\nA novel algorithm selects the next node by prioritizing nodes with the greatest difference between the direct distance from the current node to the destination node and the average indirect distance from the current node to the unvisited nodes.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    max_score = -np.inf\n    next_node = None\n    \n    direct_dist_current_to_dest = distance_matrix[current_node][destination_node]\n    avg_indirect_dist = np.mean([distance_matrix[current_node][other] for other in unvisited_nodes if other != destination_node])\n    \n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        \n        indirect_dist_current_to_node = distance_matrix[current_node][node]\n        \n        score = direct_dist_current_to_dest - indirect_dist_current_to_node - avg_indirect_dist\n        \n        if score > max_score:\n            max_score = score\n            next_node = node\n            \n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     },
     {
          "algorithm": "\nThe new algorithm selects the next node by considering the combination of the minimum distance to the destination node and the maximum distance from the current node among unvisited nodes.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance_to_destination = np.inf\n    max_distance_from_current = 0\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_to_node_distance = distance_matrix[current_node][node]\n        node_to_destination_distance = distance_matrix[node][destination_node]\n        \n        if current_to_node_distance + node_to_destination_distance < min_distance_to_destination:\n            min_distance_to_destination = current_to_node_distance + node_to_destination_distance\n            max_distance_from_current = current_to_node_distance\n            next_node = node\n        elif current_to_node_distance + node_to_destination_distance == min_distance_to_destination and current_to_node_distance > max_distance_from_current:\n            max_distance_from_current = current_to_node_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.6436,
          "other_inf": null
     },
     {
          "algorithm": "\nPropose an algorithm that selects the next node by prioritizing the node which is the farthest from the destination node among the unvisited nodes and has the shortest total distance to other unvisited nodes, aiming to balance between reaching the destination efficiently and maintaining optimal connections; \n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances_to_dest = np.sqrt(np.sum((distance_matrix[unvisited_nodes] - distance_matrix[destination_node])**2, axis=1))\n    farthest_node = unvisited_nodes[np.argmax(distances_to_dest)]\n    \n    connections = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes] > 0, axis=1)\n    total_dist_to_other_nodes = np.sum(distance_matrix[farthest_node, unvisited_nodes])\n    \n    eligible_nodes = unvisited_nodes[np.nonzero(connections)]\n    \n    if len(eligible_nodes) > 0:\n        optimal_node = eligible_nodes[np.argmin(total_dist_to_other_nodes)]\n    else:\n        optimal_node = farthest_node\n    \n    if farthest_node == optimal_node:\n        next_node = farthest_node\n    else:\n        next_node = min(farthest_node, optimal_node)\n    \n    return next_node",
          "objective": 9.43813,
          "other_inf": null
     }
]