[
     {
          "algorithm": "\nNovel algorithm: At each step, compute the product of the distances from the current node to each unvisited node and choose the unvisited node corresponding to the minimum product as the next node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    product_distances = np.prod(distances_to_unvisited, axis=0)\n    next_node_idx = np.argmin(product_distances)\n    next_node = unvisited_nodes[next_node_idx]\n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm selects the next node by considering the ratio between the square of the distance from the current node to each unvisited node and the cube of the distance from the destination node to each unvisited node, choosing the node with the minimum ratio.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances_from_current = distance_matrix[current_node, unvisited_nodes]\n    distances_to_destination = distance_matrix[destination_node, unvisited_nodes]\n    \n    ratios = np.square(distances_from_current) / np.power(distances_to_destination, 3)\n    next_node_idx = np.argmin(ratios)\n    \n    next_node = unvisited_nodes[next_node_idx]\n    \n    return next_node",
          "objective": 7.1129,
          "other_inf": null
     },
     {
          "algorithm": "\nNovel algorithm: At each step, the next node is selected based on the minimum product of the distances from the current node to unvisited nodes and the distances from the unvisited nodes to the destination node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances_to_nodes = distance_matrix[current_node, unvisited_nodes]\n    dest_distances = distance_matrix[unvisited_nodes, destination_node]\n    products = distances_to_nodes * dest_distances\n    next_node = unvisited_nodes[np.argmin(products)]\n    return next_node",
          "objective": 7.31099,
          "other_inf": null
     },
     {
          "algorithm": "\nProposed algorithm: The new algorithm selects the next node by prioritizing nodes that are closer to the destination node but have not been visited yet, using a combination of the distance from the current node to unvisited nodes and the distance from each unvisited node to the destination.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    unvisited_distances = distance_matrix[current_node, unvisited_nodes]\n    dest_distances = distance_matrix[unvisited_nodes, destination_node]\n    combined_distances = unvisited_distances + dest_distances\n    next_node = unvisited_nodes[np.argmin(combined_distances)]\n    return next_node",
          "objective": 7.6436,
          "other_inf": null
     }
]