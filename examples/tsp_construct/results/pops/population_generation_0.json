[
     {
          "algorithm": "\nProposed algorithm: Iterate through unvisited_nodes and select the node that minimizes the product of the current node's distance to it and the reciprocal of its distance to the destination node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[destination_node][node]\n        score = current_distance * 1 / dest_distance\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    return next_node",
          "objective": 6.30341,
          "other_inf": null
     },
     {
          "algorithm": "\nDesign a novel algorithm that selects the next node based on a combination of the shortest distance to unvisited nodes and the number of remaining unvisited nodes each unvisited node is connected to, prioritizing nodes that are closer and connect to more unvisited nodes first.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     },
     {
          "algorithm": "\nNew Algorithm: The algorithm selects the next node based on the product of the distance between the current node and unvisited nodes and the distance between each unvisited node and the destination node, choosing the node with the minimum resulting product.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_product = np.inf\n    next_node = None\n    \n    for node in unvisited_nodes:\n        product = distance_matrix[current_node][node] * distance_matrix[node][destination_node]\n        if product < min_product:\n            min_product = product\n            next_node = node\n    \n    return next_node",
          "objective": 7.31099,
          "other_inf": null
     },
     {
          "algorithm": "\nProposed algorithm: An adaptive greedy approach that selects the next node based on the minimum distance to the current node while also considering the overall distance to the destination node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_dist = np.inf\n    next_node = None\n    for node in unvisited_nodes:\n        dist_to_current = distance_matrix[current_node][node]\n        dist_to_dest = distance_matrix[node][destination_node]\n        total_dist = dist_to_current + dist_to_dest\n        if total_dist < min_dist:\n            min_dist = total_dist\n            next_node = node\n    return next_node",
          "objective": 7.6436,
          "other_inf": null
     }
]